/* $Source: /usr/local/cvsroot/kroot/kss/if/rtc/idl/Telemetry.idl,v $
 * $Id: Telemetry.idl,v 1.2 2007/09/27 23:26:04 intdev Exp $
 * -*- Mode: c++ -*-
 */

/**
 * @file
 * Interface definition for basic telemetry structures and iterators.
 *
 * @author Richard Johnson
 * @par Address:
 * JPL m/s 171-113, Pasadena California 91109
 * @par Copyright:
 * (c) 2002-2004, California Institute of Technology, Pasadena CA
 * @version $Revision: 1.2 $
 * @date $Date: 2007/09/27 23:26:04 $
 */

#ifndef INC_RTC_TELEMETRY_IDL
#define INC_RTC_TELEMETRY_IDL

#include <orb.idl>

#ifndef VXWORKS

#include "Name.idl"
#include "Range.idl"

#endif

#pragma prefix "rtc.jpl.nasa.gov"


module RTC {
  module Telemetry {

    typedef long IdType;

    /// Telemetry packet header structure
    struct Header {
      IdType Id;  ///< Telemetry source id
      long lSequenceNumber; ///< Sequence number to help with ordering packets
      long long llTimeFirst; ///< Time of the first value in the packet
      long long llTimeLast;  ///< Time of the last value in the packet
      double dRate; ///< Sample rate between values in the packet
    };

    // Telemetry packet structure
    struct Packet {
      Telemetry::Header Header;  ///< Packet header info
      any Data; ///< Packet data
    };

    struct NameIdPair {
      RTC::NameType Name;
      IdType Id;
    };

    typedef sequence<NameIdPair> NameIdPairSequenceType;


    /// A CORBA-style iterator for getting channel id information
    interface IdIterator : RTC::Destructible {

      /**
       *  Get the next name.
       *  @param NameId The next name-id pair
       *  @return 0 if no more names 1 if more name-id pairs
       */
      boolean NextOne(out NameIdPair NameId);

      /**
       *  Get the next N name-id pairs.
       *  @param N Maximum number of name-id the caller can handle
       *  @param Data List of the next available name-id pairs
       *  @return 0 if no more name-id pairs 1 if more names
       */
      boolean NextN(in unsigned long N, out NameIdPairSequenceType Data);
    };

    /// Metadata for telemetry sources
    struct MetaData {
      string ShortName; ///< Nickname for the telemetry source
      string Description; ///< Longer description about the telemetry channel
      string VersionTag; ///< Version tag for the source
      string VersionDetails; ///< Details about the version
      string Units; ///< Physical units
      CORBA::TypeCode DataType; ///< Type of data published by source
      RTC::AlarmSequenceType Alarms; ///< Alarm ranges
      RTC::NameSequenceType FilterNames; ///< List of filter object names
    };

    /// Sequence of meta data structures
    typedef sequence<MetaData> MetaDataSequenceType;

    struct NameMetaDataPair {
      RTC::NameType Name;
      Telemetry::MetaData MetaData;
    };

    typedef sequence<NameMetaDataPair> NameMetaDataPairSequenceType;


    /// A CORBA-style iterator for getting meta data information
    interface MetaDataIterator : RTC::Destructible {

      /**
       *  Get the next name.
       *  @param Data The next name-id pair
       *  @return 0 if no more names 1 if more names
       */
      boolean NextOne(out NameMetaDataPair Data);

      /**
       *  Get the next N names.
       *  @param N Maximum number of name-id the caller can handle
       *  @param Data List of the next available names
       *  @return 0 if no more names 1 if more names
       */
      boolean NextN(in unsigned long N,
                    out NameMetaDataPairSequenceType Data);
    };
  };
};

#endif
