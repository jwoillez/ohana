/* $Source: /usr/local/cvsroot/kroot/kss/if/rtc/idl/ConfigAPI.idl,v $
 * $Id: ConfigAPI.idl,v 1.2 2007/09/27 23:25:55 intdev Exp $
 */

/**
 * @file
 * The interface definition for the ConfigAPI server.
 * @ingroup Configuration
 *
 * Developed by Cleanroom Software Engineering for
 * Jet Propulsion Laboratory.
 *
 * @author Michael Deck
 */

#ifndef INC_CONFIGSERVER_API_MAIN_IDL
#define INC_CONFIGSERVER_API_MAIN_IDL

#pragma prefix "rtc.jpl.nasa.gov"

#include "Name.idl"
#include "Configuration.idl"
#include "ConfigAPICommon.idl"
#include "ConfigAPIEnums.idl"
#include "ConfigAPIExceptions.idl"
#include "ConfigAPIStructs.idl"
#include "ConfigAPIBase.idl"
#include "ConfigAPIRepository.idl"
#include "ConfigAPIVersion.idl"
#include "ConfigAPIWorkspace.idl"
#include "ConfigAPIModule.idl"
#include "ConfigAPIQuery.idl"
#include "ConfigAPIClassOrMember.idl"
#include "ConfigAPIInstanceOrMember.idl"
#include "ConfigAPIUsers.idl"
#include <CosEventComm.idl>
#include <CosEventChannelAdmin.idl>

module RTC {
  module Configuration {
    /**
     * @addtogroup Configuration
     * @{
     */
    /**
     * Defines high-level operations not specific to any other structure.
     */
    interface ConfigAPI: ConfigAPIBase,
      ConfigAPIRepository, ConfigAPIVersion, ConfigAPIWorkspace, ConfigAPIModule,
      ConfigAPIQuery, ConfigAPIClassOrMember, ConfigAPIInstanceOrMember, ConfigAPIUsers
    {
      /**
       * Clear the entire server cache.
       *
       * @throws ConfigAPIException on errors
       * @throws TaskKilledException if the task was stopped by the user
       */
      void cacheClear
        ()
          raises (ConfigAPIException, TaskKilledException);


      /** Request the server to cache all items in the workspace.
       *
       * @throws ConfigAPIException on errors
       * @throws TaskKilledException if task stopped by user
       */
      void cacheWorkspace
        (in string workspaceName)
        raises (ConfigAPIException, TaskKilledException);

      /**
       * Clear the server cache for this workspace.
       *
       * @throws ConfigAPIException on errors
       */
      void cacheClearWorkspace
        (in string workspaceName)
          raises (ConfigAPIException, TaskKilledException);

      /**
       * Load the module recursively into cache
       *
       * @throws ConfigAPIException on errors
       */
      void cacheModule
        (in string workspaceName, in ModuleIDStruct moduleToCache)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Clear the module info (including all classes and instances) from cache
        *
        * @throws ConfigAPIException on errors
        */
      void cacheClearModule
        (in string workspaceName, in ModuleIDStruct moduleToClear)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Load the instance or member recursively into cache
        *
        * @throws ConfigAPIException on errors
        */
      void cacheInstanceOrMember
        (in string workspaceName, in InstanceOrMemberIDStruct instanceToCache)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Checkin the items in itemList to the repository. Always checkin
        * any newly-added items on which itemList items depend, recursively.
        * <p>Events: TBD
        *
        * @param workspaceName the workspace to use
        * @param items the items to checkin
        * @param userName user name string for logging
        * @param logMessage message to include in log
        * @param recursiveContains whether or not to recursively checkin items contained
        * @param includeRemovedItems whether or not to checkin removed items subordinate to itemList items
        * (is only effective if recursiveContains)
        * @param iterator holder to take item IDs that were checked in
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      void checkinItems
        (in string workspaceName, in ItemList items,
         in string userName, in string logMessage,
         in boolean recursiveContains, in boolean includeRemovedItems,
         inout ItemIterator iterator)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Checkout the items from the repository into the workspace. If any
        * sticky-tagged item is in the way (either of a merge or a replace),
        * ConfigAPIException is thrown with messages you can inspect. There are also
        * warnings generated for things you might want to know about but aren't
        * errors.
        * <p>Events: TBD
        *
        * @param  workspaceName The workspace to checkout into
        * @param  items The items to checkout
        * @param  versionToCheckout optional tag or branch
        * @param  branchToAddModule if checking out a sticky tag and need to enroll module or query
        * @param  recursiveContains whether or not to recursively checkout items contained
        * @param  merge to have the merge results stay on the target's branch/tag
        * @param  preserveLocalMods don't overwrite attributes of LM or LR items
        * @param  commitPartial to do partial commits during checkout
        * @param  validateAfterCheckout to validate the workspace after the checkout (recommended)
        * @param  pruneMissing to remove items from the workspace that aren't in the version
        * @param  useSelectedDate to inspect selectedDateAsString and use it
        * @param  getOriginalAttributes to have merges collect original attributes for possible diff
        * @param  diffOnly only diff, don't apply
        * @param  selectedDateAsString to describe date limitation as ISO-format stringified date
        * @param  messages iterator for messages returned by checkout
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      void checkoutItems
        (in string workspaceName, in ItemList items,
         in VersionIDStruct versionToCheckout,
         in VersionIDStruct branchToAddModule,
         in boolean recursiveContains, in boolean merge, in boolean preserveLocalMods,
         in boolean commitPartial,
         in boolean validateAfterCheckout,
         in boolean pruneMissing,
         in boolean useSelectedDate,
         in boolean getOriginalAttributes,
         in boolean diffOnly,
         in string selectedDateAsString,
         inout StringIterator messages)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Produce messages describing differences between current items and items in repository.
        * <p>Events: TBD
        *
        * @param  workspaceName The workspace to diff
        * @param  items The items to diff
        * @param  versionToCheckout optional tag or branch
        * @param  recursiveContains whether or not to recursively diff items contained
        * @param  useSelectedDate to inspect selectedDateAsString and use it
        * @param  selectedDateAsString to describe date limitation as ISO-format stringified date
        * @param  messages iterator for messages returned by checkout
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      void diffItems
        (in string workspaceName,
         in ItemList items,
         in VersionIDStruct versionToCheckout,
         in boolean recursiveContains,
         in boolean useSelectedDate,
         in string selectedDateAsString,
         inout StringIterator messages)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Copy sourceItems from sourceWorkspaceName in sourceAPI to targetWorkspaceName in this API.
        * <p>Events: just about everything
        *
        * @param sourceAPI source config server from which to get source item info, may be same as this
        * @param sourceWorkspaceName source workspace name from which to get source items,
        * cannot be same as targetWorkspaceName if source and target API are the same
        * @param targetWorkspaceName target workspace name to place items
        * @param sourceItems items to be copied
        * @param branchToAddModule nonnull branch to use if modules or queries are added to target
        * @param mergeIfExists if the source item already exists in the target, merge onto the target or
        * leave target as-is
        * @param recursive to traverse into contained items and copy them
        * @param messages Iterator for messages returned by checkout
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      void copyItems
        (in ConfigAPI sourceAPI,
         in string sourceWorkspaceName,
         in string targetWorkspaceName,
         in ItemList sourceItems,
         in VersionIDStruct branchToAddModule,
         in boolean mergeIfExists,
         in boolean recursive,
         inout StringIterator messages)
          raises (ConfigAPIException, TaskKilledException);

      void copyItemsInWorkspace
        (in string workspaceName,
         in ItemList sourceItems,
         in AnyOrNull newContainer,
         in VersionIDStruct branchToAddModule,
         in boolean mergeIfExists,
         in boolean recursive,
         in boolean bMoving,
         in string newNameForCloning,
         inout StringIterator messages)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Copy all items from sourceWorkspaceName in sourceAPI to targetWorkspaceName in this API.
        * <p>Events: just about everything
        *
        * @param sourceAPI source config server from which to get source item info, may be same as this
        * @param sourceWorkspaceName source workspace name from which to get source items,
        * cannot be same as targetWorkspaceName if source and target API are the same
        * @param targetWorkspaceName target workspace name to place items
        * @param branchToAddModule nonnull branch to use if modules or queries are added to target
        * @param mergeIfExists if the source item already exists in the target, merge onto the target or
        * leave target as-is
        * @param recursive to traverse into contained items and copy them
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      void copyWorkspace
        (in ConfigAPI sourceAPI,
         in string sourceWorkspaceName,
         in string targetWorkspaceName,
         in VersionIDStruct branchToAddModule,
         in boolean mergeIfExists,
         in boolean recursive)
           raises (ConfigAPIException, TaskKilledException);

      /**
       * Execute a stored procedure on the server.
       * @param storedProcedureName name of the procedure to execute
       * @param arguments stored procedure arguments stored as Any[]
       * @return values from procedure stored as Any[]
       */
      ItemList executeStoredProcedure
        (in string storedProcedureName,
         in ItemList arguments)
        raises (ConfigAPIException, TaskKilledException);

      /**
        * Get all connection properties for this database.
        *
        * @throws ConfigAPIException on errors
        */
      Properties getConnectionProperties
        ()
          raises (ConfigAPIException);

      /**
       * Set itemIterator to an iterator of all items that would be checked
       * in if itemList contained the checkin list. Always list
       * any newly-added items on which itemList items depend, recursively.
       *
       * @param workspaceName the workspace to use
       * @param items the items that would be checked in
       * @param recursiveContains whether or not checkin would be recursive on items contained-by
       * @param includeRemovedItems whether or not to include removed items subordinate to itemList items
       * (is only effective if recursiveContains)
       * @param iterator iterator holder to take item IDs that would be checked in
       * @throws ConfigAPIException on errors
       * @throws TaskKilledException if task stopped by user
       */
      void getCheckinListingForItems
        (in string workspaceName, in ItemList items,
         in boolean recursiveContains,
         in boolean includeRemovedItems, out ItemIterator iterator)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Return segmented iterators for all fully-attributed items referenced
        * by any element of items. If requested, recursively
        * proceed on those direct references to indirect references.
        *
        * @param workspaceName The name of workspace to look in
        * @param items The items to get references from
        * @param recursive to get indirect as well as direct references
        * @param modulesIterator iterator holder to take modules that are in closure set
        * @param typesIterator iterator holder to take classes that are in closure set
        * @param classMembersIterator iterator holder to take class members that are in closure set
        * @param topLevelInstancesIterator iterator holder to take top-level instances that are in closure set
        * @param arrayInstanceMembersIterator iterator holder to take array instance members that are in closure set
        * @param scalarInstanceMembersIterator iterator holder to take non-array instance members that are in closure set
        * @param queriesIterator iterator holder to take queries that are in closure set
        * @return total size of all iterators combined
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      long getItemsClosure
        (in string workspaceName,
         in ItemList items,
         in boolean recursive,
         out ModuleIterator modulesIterator,
         out ClassIterator typesIterator,
         out ClassIterator classMembersIterator,
         out InstanceIterator topLevelInstancesIterator,
         out InstanceIterator arrayInstanceMembersIterator,
         out InstanceIterator scalarInstanceMembersIterator,
         out QueryIterator queriesIterator)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Given a string value and the class-id its apparent type, return an optional any appropriate to
        * that string and type. The typical use for this is to have the string be the intended new override
        * value for an instance, and have the classID be the type of that instance.
        *
        * @param workspaceName workspace to look for class in
        * @param classID class to use for type conversion
        * @param value string to be converted
        * @return optional any appropriate to string and type
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      AnyOrNull makeAnyFromClassAndString
        (in string workspaceName, in ClassOrMemberIDStruct classID, in string value)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Pause the task identified by taskToStop if the task is in a pausable state.
        * @todo currently doesn't work
        *
        * @param  taskToStop
        * @throws TaskException on error
        */
      void pauseTask
        (in ConfigTaskHandle taskToStop)
          raises(TaskException);

      /**
        * Set the environment variables for workspace using newEnvironment
        * @param workspaceName workspace to change
        * @param newEnvironment new environment properties (name,value)
        *
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      void setEnvironment
        (in string workspaceName, in Properties newEnvironment)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Set the logger levels for all workspaces  using newLoggerLevels
        * @param newLoggerLevels new levels (name,stringified-level)
        *
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
		  void setLoggerLevels
        (in Properties newLoggerLevels)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Set the preferences for workspace using newPreferences
        * @param workspaceName workspace to get
        * @param newPreferences new preference values (name,stringified-value)
        *
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
		  void setPreferences
        (in string workspaceName, in Properties newPreferences)
          raises (ConfigAPIException, TaskKilledException);


      /**
        * Get the environment variables for workspace
        * @param workspaceName workspace to get
        * @return properties (name,value)
        *
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      Properties getEnvironment
        (in string workspaceName)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Get the logger levels for all workspaces
        * @return properties (name,stringified-level)
        *
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
		  Properties getLoggerLevels
        ()
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Get the preferences for workspace
        * @param workspaceName workspace to get
        * @return properties (name,stringified-value)
        *
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
		  Properties getPreferences
        (in string workspaceName)
          raises (ConfigAPIException, TaskKilledException);


      /**
        * Restart a paused task if it is restartable.
        * @todo currently doesn't work
        *
        * @param taskToStop
        * @throws TaskException
        */
      void restartTask
        (in ConfigTaskHandle taskToStop)
          raises(TaskException);

      /**
        * Return a string containing a nicely-formatted analysis of the cache. Ok, it has no
        * useful content but it is nicely-formatted. Well, maybe not that nice.
        *
        * @return string describing cache status.
        * @throws ConfigAPIException
        * @throws ConfigAPIException on errors
        */
      string showCacheStats
        ()
          raises (ConfigAPIException);

      /**
       * Return a string iterator for saving the entire database contents as a stream.
       *
       * @param asDatabaseVendor indicates what format the output is presented in
       * @return a string iterator
       */
      StringIterator saveDataAsStream
        (in DatabaseVendor asDatabaseVendor)
          raises (ConfigAPIException, TaskKilledException);

      /**
       * Return a string iterator for saving the entire database definition as a stream.
       *
       * @param asDatabaseVendor indicates what format the output is presented in
       * @return a string iterator
       */
      StringIterator saveDefinitionAsStream
        (in DatabaseVendor asDatabaseVendor)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Stop all tasks that can be stopped.
        */
      void stopAllTasks
        ();

      /**
        * Stop the task identifed by taskToStop.
        *
        * @param taskToStop task to be stopped
        * @throws TaskException on error
        */
      void stopTask
        (in ConfigTaskHandle taskToStop)
          raises(TaskException);

      /**
        * Tag itemsToTag in the repository using version and its
        * attributes. This version of the function will throw an exception if any in itemToTag
        * is not in UP-TO-DATE state or if tagged with a sticky tag
        * different from version. If version does not exist, it will be created. If
        * it does exist, it must be mutable else an exception is thrown. [A future
        * version could be written to mimic the CVS behavior which tags the
        * up-to-date version whether or not it is in the workspace.]
        * <p>Events: VersionAdded
        *
        * @param  workspaceName name of workspace to find module in
        * @param  version new tag or branch to apply to module
        * @param  itemsToTag array of Any-ified config item IDs
        * @param  recursive to tag subordinates recursively
        * @param  replaceTag to move an existing tag if it exists
        * @param messages returned as list of string, full dotted (V3 format) name of all items tagged
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      void tagItems
        (in string workspaceName, in VersionStruct version, in ItemList itemsToTag,
         in boolean recursive, in boolean replaceTag, inout StringIterator messages)
          raises (ConfigAPIException, TaskKilledException);

      /**
        * Untag itemsToUntag in the repository using version and its
        * attributes. If an item is checked out sticky on that tag,
        * it will be sticky on DeletedTag afterwards.
        *
        * @param  version tag or branch from which to remove items
        * @param  itemsToUntag array of Any-ified config item IDs
        * @param messages returned as list of string (currently none)
        * @throws ConfigAPIException on errors
        * @throws TaskKilledException if task stopped by user
        */
      void untagItems
        (in VersionStruct version, in ItemList itemsToUntag,
         inout StringIterator messages)
          raises (ConfigAPIException, TaskKilledException);

      /**
       * @param full if true, does VACUUM ANALYZE FULL else VACUUM ANALYZE
       * @throws ConfigAPIException on errors
       * @throws TaskKilledException if task stopped by user
       */
      void vacuum
        (in boolean full)
          raises (ConfigAPIException, TaskKilledException);

      void validateItems
        (in string workspaceName, in ItemList itemsToValidate,
         in boolean withRepair, inout StringIterator messages)
          raises (ConfigAPIException, TaskKilledException);
    };
    /**
     * @}
     * end Configuration
     */
  };
};

#endif //INC_CONFIGSERVER_API_MAIN_IDL
